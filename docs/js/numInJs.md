# 小数精度丢失的原因

计算机由晶体管组成，内部数据的存储和运算都采用二进制，而我们在实际生活工作中，使用的是十进制。  
因此，对于计算机内部而言，在读取计算时，产生的精度问题，本质上是使用二进制模拟十进制进行运算产生的精度问题。

## Js中的数字储存
`Js`遵守JEEE 754规范定义的64位浮点格式表示数字。
![numInJs](../assets/numInJs.jpg)

### 尾数  
我们用5.2举个🌰，5.2转换为二进制为：  
> 101.00110011...

二进制中表示有效数字统一使用以1 为底位的科学计数法，又称之为规约化。  
因此，5.2转换规格化数字表示为：  
> 1.0100110011... * 2^2

此时小数点后的`0100110011...`，即为尾数。  
尾数最长为52位，那么为什么会出现如下情况：
> Number.MAX_SAFE_INTEGER == Math.pow(2, 53) - 1  // true

显然，除了0以外，其他规格化数字的首位均为 1，对此，JEEE 754默认省略了这个1所增加的存储范围。  
实际上，尾数的有效位数为53位，因此，有上文现象出现。

### 阶码